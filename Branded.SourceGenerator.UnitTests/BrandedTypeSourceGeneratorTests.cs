// Branded - Branded types for C#
// Copyright (C) 2025 Antoine Aubry

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

using Microsoft.CodeAnalysis.Testing;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using Verify = Branded.SourceGenerator.UnitTests.CSharpSourceGeneratorVerifier<Branded.SourceGenerator.BrandedTypeSourceGenerator>;

namespace Branded.SourceGenerator.UnitTests;

public class BrandedTypeSourceGeneratorTests
{
    private static readonly ReferenceAssemblies ReferencesWithoutBranded = ReferenceAssemblies.Net.Net80;

    private static readonly ReferenceAssemblies ReferencesWithBranded = ReferencesWithoutBranded
        .AddAssemblies([
            typeof(SourceGeneratorConventionsAttribute).Assembly.Location.Replace(".dll", "")
        ]);

    [Fact]
    public async Task Common_methods_are_generated_when_no_configuration_is_performed()
    {
        await new Verify.Test
        {
            TestState =
            {
                Sources =
                {
                    """
                    namespace MyPrefix.MyNamespace;
                    public readonly partial record struct {|#0:MyIdentifier|}(long Id);
                    """
                },
                GeneratedSources =
                {
                    (typeof(BrandedTypeSourceGenerator), @"MyPrefix.MyNamespace_MyIdentifier.g.cs", SourceText.From(
                        """
                        // <auto-generated />
                        #pragma warning disable 1591
                        namespace MyPrefix.MyNamespace;

                        partial record struct MyIdentifier
                            : global::System.IComparable
                            , global::System.IComparable<global::MyPrefix.MyNamespace.MyIdentifier>
                            , global::System.IFormattable
                        {
                            public sealed class Converter : global::Branded.IBrandedValueConverter<global::MyPrefix.MyNamespace.MyIdentifier, long>
                            {
                                public global::MyPrefix.MyNamespace.MyIdentifier Wrap(long value) => new global::MyPrefix.MyNamespace.MyIdentifier(value);
                                public long Unwrap(global::MyPrefix.MyNamespace.MyIdentifier value) => value.Id;
                            }

                            public static void Dispatch(global::Branded.IBrandedTypeDispatcher dispatcher) => dispatcher.Dispatch<global::MyPrefix.MyNamespace.MyIdentifier, long, global::MyPrefix.MyNamespace.MyIdentifier.Converter>();

                            public override string ToString() => Id.ToString();

                            public static implicit operator long(global::MyPrefix.MyNamespace.MyIdentifier value) => value.Id;

                            int global::System.IComparable.CompareTo(object other) => CompareTo((global::MyPrefix.MyNamespace.MyIdentifier)other);

                            public int CompareTo(global::MyPrefix.MyNamespace.MyIdentifier other) => Id.CompareTo(other.Id);

                            public string ToString(string format, global::System.IFormatProvider formatProvider) => Id.ToString(format, formatProvider);
                        }
                        """,
                        Encoding.UTF8
                    ))
                },
                ReferenceAssemblies = ReferencesWithBranded,
                ExpectedDiagnostics =
                {
                    new DiagnosticResult(GeneratorDiagnosticDescriptors.CodeGenerated)
                        .WithLocation(0)
                        .WithArguments("MyIdentifier"),
                }
            }
        }.RunAsync();
    }

    [Fact]
    public async Task Extra_constructors_are_allowed()
    {
        await new Verify.Test
        {
            TestState =
            {
                Sources =
                {
                    """
                    namespace MyNamespace;
                    public readonly partial record struct {|#0:MyIdentifier|}(long Id)
                    {
                        public MyIdentifier() : this(42) {}
                        public MyIdentifier(uint low, int high) : this((long)high << 32 | (long)low) {}
                    }
                    """
                },
                GeneratedSources =
                {
                    (typeof(BrandedTypeSourceGenerator), @"MyNamespace_MyIdentifier.g.cs", SourceText.From(
                        """
                        // <auto-generated />
                        #pragma warning disable 1591
                        namespace MyNamespace;

                        partial record struct MyIdentifier
                            : global::System.IComparable
                            , global::System.IComparable<global::MyNamespace.MyIdentifier>
                            , global::System.IFormattable
                        {
                            public override string ToString() => Id.ToString();

                            public static implicit operator long(global::MyNamespace.MyIdentifier value) => value.Id;

                            int global::System.IComparable.CompareTo(object other) => CompareTo((global::MyNamespace.MyIdentifier)other);

                            public int CompareTo(global::MyNamespace.MyIdentifier other) => Id.CompareTo(other.Id);

                            public string ToString(string format, global::System.IFormatProvider formatProvider) => Id.ToString(format, formatProvider);
                        }
                        """,
                        Encoding.UTF8
                    ))
                },
                ReferenceAssemblies = ReferencesWithoutBranded,
                ExpectedDiagnostics =
                {
                    new DiagnosticResult(GeneratorDiagnosticDescriptors.CodeGenerated)
                        .WithLocation(0)
                        .WithArguments("MyIdentifier"),
                }
            }
        }.RunAsync();
    }

    [Fact]
    public async Task Constructor_with_zero_arguments_is_rejected()
    {
        await new Verify.Test
        {
            TestState =
            {
                Sources =
                {
                    """
                    namespace MyNamespace;
                    public readonly partial record struct {|#0:MyIdentifier|}();
                    """
                },
                ReferenceAssemblies = ReferencesWithoutBranded,
                ExpectedDiagnostics =
                {
                    new DiagnosticResult(GeneratorDiagnosticDescriptors.MissingConstructor)
                        .WithLocation(0)
                        .WithArguments("MyIdentifier", "Error"),
                }
            }
        }.RunAsync();
    }

    [Fact]
    public async Task Constructor_with_multiple_arguments_is_rejected()
    {
        await new Verify.Test
        {
            TestState =
            {
                Sources =
                {
                    """
                    namespace MyNamespace;
                    public readonly partial record struct {|#0:MyIdentifier|}(int Id, string Name);
                    """
                },
                ReferenceAssemblies = ReferencesWithoutBranded,
                ExpectedDiagnostics =
                {
                    new DiagnosticResult(GeneratorDiagnosticDescriptors.MissingConstructor)
                        .WithLocation(0)
                        .WithArguments("MyIdentifier", "Error"),
                }
            }
        }.RunAsync();
    }

    [Fact]
    public async Task Types_are_filtered_when_BrandedTypeNamePattern_is_set()
    {
        await new Verify.Test
        {
            TestState =
            {
                Sources =
                {
                    """
                    [assembly:Branded.SourceGeneratorConventions(BrandedTypeNamePattern = @"Identifier$")]

                    namespace MyNamespace;
                    public readonly partial record struct {|#0:MyIdentifier|}(long Id);
                    public readonly partial record struct MyCode(long Id);
                    """
                },
                GeneratedSources =
                {
                    (typeof(BrandedTypeSourceGenerator), @"MyNamespace_MyIdentifier.g.cs", SourceText.From(
                        """
                        // <auto-generated />
                        #pragma warning disable 1591
                        namespace MyNamespace;

                        partial record struct MyIdentifier
                            : global::System.IComparable
                            , global::System.IComparable<global::MyNamespace.MyIdentifier>
                            , global::System.IFormattable
                        {
                            public sealed class Converter : global::Branded.IBrandedValueConverter<global::MyNamespace.MyIdentifier, long>
                            {
                                public global::MyNamespace.MyIdentifier Wrap(long value) => new global::MyNamespace.MyIdentifier(value);
                                public long Unwrap(global::MyNamespace.MyIdentifier value) => value.Id;
                            }

                            public static void Dispatch(global::Branded.IBrandedTypeDispatcher dispatcher) => dispatcher.Dispatch<global::MyNamespace.MyIdentifier, long, global::MyNamespace.MyIdentifier.Converter>();
                        
                            public override string ToString() => Id.ToString();

                            public static implicit operator long(global::MyNamespace.MyIdentifier value) => value.Id;

                            int global::System.IComparable.CompareTo(object other) => CompareTo((global::MyNamespace.MyIdentifier)other);

                            public int CompareTo(global::MyNamespace.MyIdentifier other) => Id.CompareTo(other.Id);

                            public string ToString(string format, global::System.IFormatProvider formatProvider) => Id.ToString(format, formatProvider);
                        }
                        """,
                        Encoding.UTF8
                    ))
                },
                ReferenceAssemblies = ReferencesWithBranded,
                ExpectedDiagnostics =
                {
                    new DiagnosticResult(GeneratorDiagnosticDescriptors.CodeGenerated)
                        .WithLocation(0)
                        .WithArguments("MyIdentifier"),
                }
            },
            CompilerDiagnostics = CompilerDiagnostics.None
        }.RunAsync();
    }

    [Fact]
    public async Task Missing_partial_is_ignored_when_BrandedTypeNamePattern_excluded_type()
    {
        await new Verify.Test
        {
            TestState =
            {
                Sources =
                {
                    """
                    [assembly:Branded.SourceGeneratorConventions(BrandedTypeNamePattern = @"Identifier$")]

                    namespace MyNamespace;
                    public readonly record struct MyCode(long Id);
                    """
                },
                ReferenceAssemblies = ReferencesWithBranded,
            },
            CompilerDiagnostics = CompilerDiagnostics.None
        }.RunAsync();
    }

    [Fact]
    public async Task Missing_constructor_is_ignored_when_BrandedTypeNamePattern_excluded_type()
    {
        await new Verify.Test
        {
            TestState =
            {
                Sources =
                {
                    """
                    [assembly:Branded.SourceGeneratorConventions(BrandedTypeNamePattern = @"Identifier$")]

                    namespace MyNamespace;
                    public readonly partial record struct MyCode();
                    """
                },
                ReferenceAssemblies = ReferencesWithBranded,
            },
            CompilerDiagnostics = CompilerDiagnostics.None
        }.RunAsync();
    }

    [Fact]
    public async Task Unknown_configuration_parameters_generate_warnings()
    {
        await new Verify.Test
        {
            TestState =
            {
                Sources =
                {
                    """
                    [assembly:{|#0:Branded.SourceGeneratorConventions(__DoNotUse = 1)|}]

                    namespace MyNamespace;
                    public readonly partial record struct {|#1:MyIdentifier|}(long Id);
                    """
                },
                GeneratedSources =
                {
                    (typeof(BrandedTypeSourceGenerator), @"MyNamespace_MyIdentifier.g.cs", SourceText.From(
                        """
                        // <auto-generated />
                        #pragma warning disable 1591
                        namespace MyNamespace;

                        partial record struct MyIdentifier
                            : global::System.IComparable
                            , global::System.IComparable<global::MyNamespace.MyIdentifier>
                            , global::System.IFormattable
                        {
                            public sealed class Converter : global::Branded.IBrandedValueConverter<global::MyNamespace.MyIdentifier, long>
                            {
                                public global::MyNamespace.MyIdentifier Wrap(long value) => new global::MyNamespace.MyIdentifier(value);
                                public long Unwrap(global::MyNamespace.MyIdentifier value) => value.Id;
                            }
                        
                            public static void Dispatch(global::Branded.IBrandedTypeDispatcher dispatcher) => dispatcher.Dispatch<global::MyNamespace.MyIdentifier, long, global::MyNamespace.MyIdentifier.Converter>();
                        
                            public override string ToString() => Id.ToString();

                            public static implicit operator long(global::MyNamespace.MyIdentifier value) => value.Id;

                            int global::System.IComparable.CompareTo(object other) => CompareTo((global::MyNamespace.MyIdentifier)other);

                            public int CompareTo(global::MyNamespace.MyIdentifier other) => Id.CompareTo(other.Id);

                            public string ToString(string format, global::System.IFormatProvider formatProvider) => Id.ToString(format, formatProvider);
                        }
                        """,
                        Encoding.UTF8
                    ))
                },
                ReferenceAssemblies = ReferencesWithBranded,
                ExpectedDiagnostics =
                {
                    new DiagnosticResult(GeneratorDiagnosticDescriptors.UnsupportedConfiguration)
                        .WithLocation(0)
                        .WithArguments("__DoNotUse"),
                    new DiagnosticResult(GeneratorDiagnosticDescriptors.CodeGenerated)
                        .WithLocation(1)
                        .WithArguments("MyIdentifier"),
                }
            },
            CompilerDiagnostics = CompilerDiagnostics.None
        }.RunAsync();
    }


    [Fact]
    public async Task Invalid_configuration_parameter_generates_an_error()
    {
        await new Verify.Test
        {
            TestState =
            {
                Sources =
                {
                    """
                    [assembly:{|#0:Branded.SourceGeneratorConventions(BrandedTypeNamePattern = @"invalid regex: (\")|}]

                    namespace MyNamespace;
                    public readonly partial record struct MyIdentifier(long Id);
                    public readonly partial record struct MyOtherIdentifier(long Id);
                    """
                },
                ReferenceAssemblies = ReferencesWithBranded,
                ExpectedDiagnostics =
                {
                    new DiagnosticResult(GeneratorDiagnosticDescriptors.InvalidConfiguration)
                        .WithLocation(0)
                        .WithArguments(@"Invalid pattern 'invalid regex: (\' at offset 17. Illegal \ at end of pattern.")
                }
            },
            CompilerDiagnostics = CompilerDiagnostics.None
        }.RunAsync();
    }

    [Fact]
    public async Task Custom_attributes_can_be_added()
    {
        await new Verify.Test
        {
            TestState =
            {
                Sources =
                {
                    """
                    using System;

                    [assembly:Branded.SourceGeneratorCustomAttribute(
                        typeof(MyNamespace.MyFirstCustomAttribute)
                    ),Branded.SourceGeneratorCustomAttribute(
                        typeof(MyNamespace.MySecondCustomAttribute)
                    )]
                    [assembly:Branded.SourceGeneratorCustomAttribute(
                        typeof(MyNamespace.MyThirdCustomAttribute)
                    )]

                    namespace MyNamespace
                    {
                        public readonly partial record struct {|#0:MyIdentifier|}(long Id);
                        
                        [AttributeUsage(AttributeTargets.All)]
                        public class MyFirstCustomAttribute : Attribute {}
                        
                        [AttributeUsage(AttributeTargets.All)]
                        public class MySecondCustomAttribute : Attribute {}
                        
                        [AttributeUsage(AttributeTargets.All)]
                        public class MyThirdCustomAttribute : Attribute {}
                    }
                    """
                },
                GeneratedSources =
                {
                    (typeof(BrandedTypeSourceGenerator), @"MyNamespace_MyIdentifier.g.cs", SourceText.From(
                        """
                        // <auto-generated />
                        #pragma warning disable 1591
                        namespace MyNamespace;

                        [global::MyNamespace.MyFirstCustomAttribute()]
                        [global::MyNamespace.MySecondCustomAttribute()]
                        [global::MyNamespace.MyThirdCustomAttribute()]
                        partial record struct MyIdentifier
                            : global::System.IComparable
                            , global::System.IComparable<global::MyNamespace.MyIdentifier>
                            , global::System.IFormattable
                        {
                            public sealed class Converter : global::Branded.IBrandedValueConverter<global::MyNamespace.MyIdentifier, long>
                            {
                                public global::MyNamespace.MyIdentifier Wrap(long value) => new global::MyNamespace.MyIdentifier(value);
                                public long Unwrap(global::MyNamespace.MyIdentifier value) => value.Id;
                            }

                            public static void Dispatch(global::Branded.IBrandedTypeDispatcher dispatcher) => dispatcher.Dispatch<global::MyNamespace.MyIdentifier, long, global::MyNamespace.MyIdentifier.Converter>();
                        
                            public override string ToString() => Id.ToString();

                            public static implicit operator long(global::MyNamespace.MyIdentifier value) => value.Id;

                            int global::System.IComparable.CompareTo(object other) => CompareTo((global::MyNamespace.MyIdentifier)other);

                            public int CompareTo(global::MyNamespace.MyIdentifier other) => Id.CompareTo(other.Id);

                            public string ToString(string format, global::System.IFormatProvider formatProvider) => Id.ToString(format, formatProvider);
                        }
                        """,
                        Encoding.UTF8
                    ))
                },
                ReferenceAssemblies = ReferencesWithBranded,
                ExpectedDiagnostics =
                {
                    new DiagnosticResult(GeneratorDiagnosticDescriptors.CodeGenerated)
                        .WithLocation(0)
                        .WithArguments("MyIdentifier"),
                }
            }
        }.RunAsync();
    }

    [Fact]
    public async Task Custom_attributes_can_be_added_with_parameters()
    {
        await new Verify.Test
        {
            TestState =
            {
                Sources =
                {
                    """
                    using System;

                    [assembly:Branded.SourceGeneratorCustomAttribute(
                        typeof(MyNamespace.MyCustomAttribute),
                        ConstructorArguments = [
                            typeof(Branded.BrandedTypePlaceholder),
                            typeof(Branded.BrandedInnerTypePlaceholder),
                            "hello, {0}"
                        ],
                        NamedArguments = [
                            "Details",
                            "Some details"
                        ]
                    )]

                    namespace MyNamespace
                    {
                        public readonly partial record struct {|#0:MyIdentifier|}(long Id);
                        
                        [AttributeUsage(AttributeTargets.All)]
                        public class MyCustomAttribute(Type identifierType, Type innerType, string value) : Attribute
                        {
                            public Type IdentifierType { get; } = identifierType;
                            public Type InnerType { get; } = innerType;
                            public string Value { get; } = value;
                            public string Details { get; set; }
                        }
                    }
                    """
                },
                GeneratedSources =
                {
                    (typeof(BrandedTypeSourceGenerator), @"MyNamespace_MyIdentifier.g.cs", SourceText.From(
                        """
                        // <auto-generated />
                        #pragma warning disable 1591
                        namespace MyNamespace;

                        [global::MyNamespace.MyCustomAttribute(typeof(global::MyNamespace.MyIdentifier), typeof(long), "hello, {0}", Details = "Some details")]
                        partial record struct MyIdentifier
                            : global::System.IComparable
                            , global::System.IComparable<global::MyNamespace.MyIdentifier>
                            , global::System.IFormattable
                        {
                            public sealed class Converter : global::Branded.IBrandedValueConverter<global::MyNamespace.MyIdentifier, long>
                            {
                                public global::MyNamespace.MyIdentifier Wrap(long value) => new global::MyNamespace.MyIdentifier(value);
                                public long Unwrap(global::MyNamespace.MyIdentifier value) => value.Id;
                            }

                            public static void Dispatch(global::Branded.IBrandedTypeDispatcher dispatcher) => dispatcher.Dispatch<global::MyNamespace.MyIdentifier, long, global::MyNamespace.MyIdentifier.Converter>();
                        
                            public override string ToString() => Id.ToString();

                            public static implicit operator long(global::MyNamespace.MyIdentifier value) => value.Id;

                            int global::System.IComparable.CompareTo(object other) => CompareTo((global::MyNamespace.MyIdentifier)other);

                            public int CompareTo(global::MyNamespace.MyIdentifier other) => Id.CompareTo(other.Id);

                            public string ToString(string format, global::System.IFormatProvider formatProvider) => Id.ToString(format, formatProvider);
                        }
                        """,
                        Encoding.UTF8
                    ))
                },
                ReferenceAssemblies = ReferencesWithBranded,
                ExpectedDiagnostics =
                {
                    new DiagnosticResult(GeneratorDiagnosticDescriptors.CodeGenerated)
                        .WithLocation(0)
                        .WithArguments("MyIdentifier"),
                }
            }
        }.RunAsync();
    }

    [Fact]
    public async Task Custom_attributes_can_be_added_with_parameters_having_generic_arguments()
    {
        await new Verify.Test
        {
            TestState =
            {
                Sources =
                {
                    """
                    using System;

                    [assembly:Branded.SourceGeneratorCustomAttribute(
                        typeof(OtherNamespace.CustomConverterAttribute),
                        ConstructorArguments = [
                            typeof(MyNamespace.MyCustomConverter<Branded.BrandedTypePlaceholder, Branded.BrandedInnerTypePlaceholder, Branded.BrandedConverterTypePlaceholder>)
                        ]
                    )]

                    namespace MyNamespace
                    {
                        public readonly partial record struct {|#0:MyIdentifier|}(long Id);
                        
                        public class MyCustomConverter<TIdentifier, TInner, TConverter>
                        {
                        }
                    }

                    namespace OtherNamespace
                    {
                        [AttributeUsage(AttributeTargets.All)]
                        public class CustomConverterAttribute(Type converterType) : Attribute
                        {
                            public Type ConverterType { get; } = converterType;
                        }
                    }
                    """
                },
                GeneratedSources =
                {
                    (typeof(BrandedTypeSourceGenerator), @"MyNamespace_MyIdentifier.g.cs", SourceText.From(
                        """
                        // <auto-generated />
                        #pragma warning disable 1591
                        namespace MyNamespace;

                        [global::OtherNamespace.CustomConverterAttribute(typeof(global::MyNamespace.MyCustomConverter<global::MyNamespace.MyIdentifier, long, global::MyNamespace.MyIdentifier.Converter>))]
                        partial record struct MyIdentifier
                            : global::System.IComparable
                            , global::System.IComparable<global::MyNamespace.MyIdentifier>
                            , global::System.IFormattable
                        {
                            public sealed class Converter : global::Branded.IBrandedValueConverter<global::MyNamespace.MyIdentifier, long>
                            {
                                public global::MyNamespace.MyIdentifier Wrap(long value) => new global::MyNamespace.MyIdentifier(value);
                                public long Unwrap(global::MyNamespace.MyIdentifier value) => value.Id;
                            }

                            public static void Dispatch(global::Branded.IBrandedTypeDispatcher dispatcher) => dispatcher.Dispatch<global::MyNamespace.MyIdentifier, long, global::MyNamespace.MyIdentifier.Converter>();
                        
                            public override string ToString() => Id.ToString();

                            public static implicit operator long(global::MyNamespace.MyIdentifier value) => value.Id;

                            int global::System.IComparable.CompareTo(object other) => CompareTo((global::MyNamespace.MyIdentifier)other);

                            public int CompareTo(global::MyNamespace.MyIdentifier other) => Id.CompareTo(other.Id);

                            public string ToString(string format, global::System.IFormatProvider formatProvider) => Id.ToString(format, formatProvider);
                        }
                        """,
                        Encoding.UTF8
                    ))
                },
                ReferenceAssemblies = ReferencesWithBranded,
                ExpectedDiagnostics =
                {
                    new DiagnosticResult(GeneratorDiagnosticDescriptors.CodeGenerated)
                        .WithLocation(0)
                        .WithArguments("MyIdentifier"),
                }
            }
        }.RunAsync();
    }

    [Fact]
    public async Task Custom_attributes_can_be_added_with_parameters_having_unbound_generic_arguments()
    {
        await new Verify.Test
        {
            TestState =
            {
                Sources =
                {
                    """
                    using System;

                    [assembly:Branded.SourceGeneratorCustomAttribute(
                        typeof(OtherNamespace.CustomConverterAttribute),
                        ConstructorArguments = [
                            new[] {
                                typeof(MyNamespace.MyCustomConverter<,,>),
                                typeof(Branded.BrandedTypePlaceholder),
                                typeof(Branded.BrandedInnerTypePlaceholder),
                                typeof(Branded.BrandedConverterTypePlaceholder),
                            }
                        ]
                    )]

                    namespace MyNamespace
                    {
                        public readonly partial record struct {|#0:MyIdentifier|}(long Id);
                        
                        public class MyCustomConverter<TIdentifier, TInner, TConverter>
                        {
                        }
                    }

                    namespace OtherNamespace
                    {
                        [AttributeUsage(AttributeTargets.All)]
                        public class CustomConverterAttribute(Type converterType) : Attribute
                        {
                            public Type ConverterType { get; } = converterType;
                        }
                    }
                    """
                },
                GeneratedSources =
                {
                    (typeof(BrandedTypeSourceGenerator), @"MyNamespace_MyIdentifier.g.cs", SourceText.From(
                        """
                        // <auto-generated />
                        #pragma warning disable 1591
                        namespace MyNamespace;

                        [global::OtherNamespace.CustomConverterAttribute(typeof(global::MyNamespace.MyCustomConverter<global::MyNamespace.MyIdentifier, long, global::MyNamespace.MyIdentifier.Converter>))]
                        partial record struct MyIdentifier
                            : global::System.IComparable
                            , global::System.IComparable<global::MyNamespace.MyIdentifier>
                            , global::System.IFormattable
                        {
                            public sealed class Converter : global::Branded.IBrandedValueConverter<global::MyNamespace.MyIdentifier, long>
                            {
                                public global::MyNamespace.MyIdentifier Wrap(long value) => new global::MyNamespace.MyIdentifier(value);
                                public long Unwrap(global::MyNamespace.MyIdentifier value) => value.Id;
                            }

                            public static void Dispatch(global::Branded.IBrandedTypeDispatcher dispatcher) => dispatcher.Dispatch<global::MyNamespace.MyIdentifier, long, global::MyNamespace.MyIdentifier.Converter>();
                        
                            public override string ToString() => Id.ToString();

                            public static implicit operator long(global::MyNamespace.MyIdentifier value) => value.Id;

                            int global::System.IComparable.CompareTo(object other) => CompareTo((global::MyNamespace.MyIdentifier)other);

                            public int CompareTo(global::MyNamespace.MyIdentifier other) => Id.CompareTo(other.Id);

                            public string ToString(string format, global::System.IFormatProvider formatProvider) => Id.ToString(format, formatProvider);
                        }
                        """,
                        Encoding.UTF8
                    ))
                },
                ReferenceAssemblies = ReferencesWithBranded,
                ExpectedDiagnostics =
                {
                    new DiagnosticResult(GeneratorDiagnosticDescriptors.CodeGenerated)
                        .WithLocation(0)
                        .WithArguments("MyIdentifier"),
                }
            }
        }.RunAsync();
    }

    [Fact]
    public async Task Custom_attributes_apply_when_inner_type_exists_in_OnlyForInnerTypes()
    {
        await new Verify.Test
        {
            TestState =
            {
                Sources =
                {
                    """
                    using System;

                    [assembly:Branded.SourceGeneratorCustomAttribute(
                        typeof(MyNamespace.OnlyForInt32Attribute),
                        OnlyForInnerTypes = [ typeof(int) ]
                    )]

                    namespace MyNamespace
                    {
                        public readonly partial record struct {|#0:MyIdentifier|}(int Id);
                        
                        [AttributeUsage(AttributeTargets.All)]
                        public class OnlyForInt32Attribute : Attribute
                        {
                        }
                    }
                    """
                },
                GeneratedSources =
                {
                    (typeof(BrandedTypeSourceGenerator), @"MyNamespace_MyIdentifier.g.cs", SourceText.From(
                        """
                        // <auto-generated />
                        #pragma warning disable 1591
                        namespace MyNamespace;

                        [global::MyNamespace.OnlyForInt32Attribute()]
                        partial record struct MyIdentifier
                            : global::System.IComparable
                            , global::System.IComparable<global::MyNamespace.MyIdentifier>
                            , global::System.IFormattable
                        {
                            public sealed class Converter : global::Branded.IBrandedValueConverter<global::MyNamespace.MyIdentifier, int>
                            {
                                public global::MyNamespace.MyIdentifier Wrap(int value) => new global::MyNamespace.MyIdentifier(value);
                                public int Unwrap(global::MyNamespace.MyIdentifier value) => value.Id;
                            }

                            public static void Dispatch(global::Branded.IBrandedTypeDispatcher dispatcher) => dispatcher.Dispatch<global::MyNamespace.MyIdentifier, int, global::MyNamespace.MyIdentifier.Converter>();
                        
                            public override string ToString() => Id.ToString();

                            public static implicit operator int(global::MyNamespace.MyIdentifier value) => value.Id;

                            int global::System.IComparable.CompareTo(object other) => CompareTo((global::MyNamespace.MyIdentifier)other);

                            public int CompareTo(global::MyNamespace.MyIdentifier other) => Id.CompareTo(other.Id);

                            public string ToString(string format, global::System.IFormatProvider formatProvider) => Id.ToString(format, formatProvider);
                        }
                        """,
                        Encoding.UTF8
                    ))
                },
                ReferenceAssemblies = ReferencesWithBranded,
                ExpectedDiagnostics =
                {
                    new DiagnosticResult(GeneratorDiagnosticDescriptors.CodeGenerated)
                        .WithLocation(0)
                        .WithArguments("MyIdentifier"),
                }
            }
        }.RunAsync();
    }

    [Fact]
    public async Task Custom_attributes_do_not_apply_when_inner_type_does_not_exist_in_OnlyForInnerTypes()
    {
        await new Verify.Test
        {
            TestState =
            {
                Sources =
                {
                    """
                    using System;

                    [assembly:Branded.SourceGeneratorCustomAttribute(
                        typeof(MyNamespace.OnlyForInt32Attribute),
                        OnlyForInnerTypes = [ typeof(int) ]
                    )]

                    namespace MyNamespace
                    {
                        public readonly partial record struct {|#0:MyIdentifier|}(long Id);
                        
                        [AttributeUsage(AttributeTargets.All)]
                        public class OnlyForInt32Attribute : Attribute
                        {
                        }
                    }
                    """
                },
                GeneratedSources =
                {
                    (typeof(BrandedTypeSourceGenerator), @"MyNamespace_MyIdentifier.g.cs", SourceText.From(
                        """
                        // <auto-generated />
                        #pragma warning disable 1591
                        namespace MyNamespace;

                        partial record struct MyIdentifier
                            : global::System.IComparable
                            , global::System.IComparable<global::MyNamespace.MyIdentifier>
                            , global::System.IFormattable
                        {
                            public sealed class Converter : global::Branded.IBrandedValueConverter<global::MyNamespace.MyIdentifier, long>
                            {
                                public global::MyNamespace.MyIdentifier Wrap(long value) => new global::MyNamespace.MyIdentifier(value);
                                public long Unwrap(global::MyNamespace.MyIdentifier value) => value.Id;
                            }

                            public static void Dispatch(global::Branded.IBrandedTypeDispatcher dispatcher) => dispatcher.Dispatch<global::MyNamespace.MyIdentifier, long, global::MyNamespace.MyIdentifier.Converter>();
                        
                            public override string ToString() => Id.ToString();

                            public static implicit operator long(global::MyNamespace.MyIdentifier value) => value.Id;

                            int global::System.IComparable.CompareTo(object other) => CompareTo((global::MyNamespace.MyIdentifier)other);

                            public int CompareTo(global::MyNamespace.MyIdentifier other) => Id.CompareTo(other.Id);

                            public string ToString(string format, global::System.IFormatProvider formatProvider) => Id.ToString(format, formatProvider);
                        }
                        """,
                        Encoding.UTF8
                    ))
                },
                ReferenceAssemblies = ReferencesWithBranded,
                ExpectedDiagnostics =
                {
                    new DiagnosticResult(GeneratorDiagnosticDescriptors.CodeGenerated)
                        .WithLocation(0)
                        .WithArguments("MyIdentifier"),
                }
            }
        }.RunAsync();
    }

    [Fact]
    public async Task Custom_attributes_do_not_apply_when_inner_type_exists_in_ExceptForInnerTypes()
    {
        await new Verify.Test
        {
            TestState =
            {
                Sources =
                {
                    """
                    using System;

                    [assembly:Branded.SourceGeneratorCustomAttribute(
                        typeof(MyNamespace.NotForInt64Attribute),
                        ExceptForInnerTypes = [ typeof(long) ]
                    )]

                    namespace MyNamespace
                    {
                        public readonly partial record struct {|#0:MyIdentifier|}(long Id);
                        
                        [AttributeUsage(AttributeTargets.All)]
                        public class NotForInt64Attribute : Attribute
                        {
                        }
                    }
                    """
                },
                GeneratedSources =
                {
                    (typeof(BrandedTypeSourceGenerator), @"MyNamespace_MyIdentifier.g.cs", SourceText.From(
                        """
                        // <auto-generated />
                        #pragma warning disable 1591
                        namespace MyNamespace;

                        partial record struct MyIdentifier
                            : global::System.IComparable
                            , global::System.IComparable<global::MyNamespace.MyIdentifier>
                            , global::System.IFormattable
                        {
                            public sealed class Converter : global::Branded.IBrandedValueConverter<global::MyNamespace.MyIdentifier, long>
                            {
                                public global::MyNamespace.MyIdentifier Wrap(long value) => new global::MyNamespace.MyIdentifier(value);
                                public long Unwrap(global::MyNamespace.MyIdentifier value) => value.Id;
                            }

                            public static void Dispatch(global::Branded.IBrandedTypeDispatcher dispatcher) => dispatcher.Dispatch<global::MyNamespace.MyIdentifier, long, global::MyNamespace.MyIdentifier.Converter>();
                        
                            public override string ToString() => Id.ToString();

                            public static implicit operator long(global::MyNamespace.MyIdentifier value) => value.Id;

                            int global::System.IComparable.CompareTo(object other) => CompareTo((global::MyNamespace.MyIdentifier)other);

                            public int CompareTo(global::MyNamespace.MyIdentifier other) => Id.CompareTo(other.Id);

                            public string ToString(string format, global::System.IFormatProvider formatProvider) => Id.ToString(format, formatProvider);
                        }
                        """,
                        Encoding.UTF8
                    ))
                },
                ReferenceAssemblies = ReferencesWithBranded,
                ExpectedDiagnostics =
                {
                    new DiagnosticResult(GeneratorDiagnosticDescriptors.CodeGenerated)
                        .WithLocation(0)
                        .WithArguments("MyIdentifier"),
                }
            }
        }.RunAsync();
    }

    [Fact]
    public async Task Custom_attributes_having_unbound_generic_arguments_must_have_correct_arity()
    {
        await new Verify.Test
        {
            TestState =
            {
                Sources =
                {
                    """
                    using System;

                    [assembly:{|#0:Branded.SourceGeneratorCustomAttribute(
                        typeof(OtherNamespace.CustomConverterAttribute),
                        ConstructorArguments = [
                            new[]
                            {
                                typeof(MyNamespace.MyCustomConverter<>),
                                typeof(Branded.BrandedTypePlaceholder),
                                typeof(string)
                            }
                        ]
                    )|}]

                    namespace MyNamespace
                    {
                        public readonly partial record struct {|#1:MyIdentifier|}(long Id);
                        
                        public class MyCustomConverter<TIdentifier>
                        {
                        }
                    }

                    namespace OtherNamespace
                    {
                        [AttributeUsage(AttributeTargets.All)]
                        public class CustomConverterAttribute(Type converterType) : Attribute
                        {
                            public Type ConverterType { get; } = converterType;
                        }
                    }
                    """
                },
                GeneratedSources =
                {
                    (typeof(BrandedTypeSourceGenerator), @"MyNamespace_MyIdentifier.g.cs", SourceText.From(
                        """
                        // <auto-generated />
                        #pragma warning disable 1591
                        namespace MyNamespace;

                        partial record struct MyIdentifier
                            : global::System.IComparable
                            , global::System.IComparable<global::MyNamespace.MyIdentifier>
                            , global::System.IFormattable
                        {
                            public sealed class Converter : global::Branded.IBrandedValueConverter<global::MyNamespace.MyIdentifier, long>
                            {
                                public global::MyNamespace.MyIdentifier Wrap(long value) => new global::MyNamespace.MyIdentifier(value);
                                public long Unwrap(global::MyNamespace.MyIdentifier value) => value.Id;
                            }

                            public static void Dispatch(global::Branded.IBrandedTypeDispatcher dispatcher) => dispatcher.Dispatch<global::MyNamespace.MyIdentifier, long, global::MyNamespace.MyIdentifier.Converter>();
                        
                            public override string ToString() => Id.ToString();

                            public static implicit operator long(global::MyNamespace.MyIdentifier value) => value.Id;

                            int global::System.IComparable.CompareTo(object other) => CompareTo((global::MyNamespace.MyIdentifier)other);

                            public int CompareTo(global::MyNamespace.MyIdentifier other) => Id.CompareTo(other.Id);

                            public string ToString(string format, global::System.IFormatProvider formatProvider) => Id.ToString(format, formatProvider);
                        }
                        """,
                        Encoding.UTF8
                    ))
                },
                ReferenceAssemblies = ReferencesWithBranded,
                ExpectedDiagnostics =
                {
                    new DiagnosticResult(GeneratorDiagnosticDescriptors.InvalidGenericType)
                        .WithLocation(0),
                    new DiagnosticResult(GeneratorDiagnosticDescriptors.CodeGenerated)
                        .WithLocation(1)
                        .WithArguments("MyIdentifier"),
                }
            }
        }.RunAsync();
    }

    [Fact]
    public async Task IBrandedValueConverter_is_omitted_if_unavailable()
    {
        await new Verify.Test
        {
            TestState =
            {
                Sources =
                {
                    """
                    namespace MyPrefix.MyNamespace;
                    public readonly partial record struct {|#0:MyIdentifier|}(long Id);
                    """
                },
                GeneratedSources =
                {
                    (typeof(BrandedTypeSourceGenerator), @"MyPrefix.MyNamespace_MyIdentifier.g.cs", SourceText.From(
                        """
                        // <auto-generated />
                        #pragma warning disable 1591
                        namespace MyPrefix.MyNamespace;

                        partial record struct MyIdentifier
                            : global::System.IComparable
                            , global::System.IComparable<global::MyPrefix.MyNamespace.MyIdentifier>
                            , global::System.IFormattable
                        {
                            public override string ToString() => Id.ToString();

                            public static implicit operator long(global::MyPrefix.MyNamespace.MyIdentifier value) => value.Id;

                            int global::System.IComparable.CompareTo(object other) => CompareTo((global::MyPrefix.MyNamespace.MyIdentifier)other);

                            public int CompareTo(global::MyPrefix.MyNamespace.MyIdentifier other) => Id.CompareTo(other.Id);

                            public string ToString(string format, global::System.IFormatProvider formatProvider) => Id.ToString(format, formatProvider);
                        }
                        """,
                        Encoding.UTF8
                    ))
                },
                ReferenceAssemblies = ReferencesWithoutBranded,
                ExpectedDiagnostics =
                {
                    new DiagnosticResult(GeneratorDiagnosticDescriptors.CodeGenerated)
                        .WithLocation(0)
                        .WithArguments("MyIdentifier"),
                }
            }
        }.RunAsync();
    }
}